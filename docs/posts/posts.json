[
  {
    "path": "posts/pipe/",
    "title": "How to use the Pipe",
    "description": "Understand the difference between the magritr pipe and the native pipe, and when \nto use each. Understand when it is better to use the pipe rather than regular \nBase R syntax.",
    "author": [
      {
        "name": "R.Andres Castaneda",
        "url": {}
      }
    ],
    "date": "2023-05-09",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nPackages\r\nloading and attaching\r\nWhen to attach\r\n\r\nMain idea of the pipe\r\nsources\r\n\r\nPackages\r\nloading and attaching\r\nThere is an important difference between loading and attaching a package.\r\nLoading refers to put all the components of a package available in memory ( code, data, and any DLLs; register S3 and S4 methods). However, those components are not in the search the search path, which is equivalent to the ado path in Stata. This is way, we need to call the function of loaded package with ::. If the packages has not been loaded, using :: loads the package.\r\nAttaching loads the package and makes it available in the search path. You do it using library() or require(). When it is attached, you don’t need to use ::, but you can.\r\nRead more here, R-Packages book.\r\nWhen to attach\r\nAttaching has the advantage of not using ::, but when you use too many packages, it is difficult to know what function comes from what package.\r\nI attach when I am using a package that I need all the time. For example, tidyverse or data.table. However, try to always use :: because the code is clearer and there is no penalty in speed (minimum).\r\nIf you are developing packages, you cannot attach packages. You always have to use ::\r\nMain idea of the pipe\r\n\r\n\r\n# load libraries that we will need\r\n\r\nlibrary(nycflights13) # data or use library(help = \"datasets\")\r\nlibrary(tidyverse)\r\nlibrary(data.table)\r\n\r\n\r\nWe need to talk first about frames. Let’s go to Stata first.\r\nAt the most basic level, the pipe is a syntax transformation in which you separate the argument from the function\r\n\r\n\r\nx = 1:10\r\n\r\n# from this\r\nmean(x)\r\n\r\n[1] 5.5\r\n\r\n# to this \r\n\r\nx |> mean()\r\n\r\n[1] 5.5\r\n\r\nBut it by itself is not super useful. You see the real power when you work with dataframes\r\n\r\n\r\n# so you go from this\r\nflights1 <- filter(flights, dest == \"IAH\")\r\nflights2 <- mutate(flights1, speed = distance / air_time * 60)\r\nflights3 <- select(flights2, year:day, dep_time, carrier, flight, speed)\r\narrange(flights3, desc(speed))\r\n\r\n\r\n# or this\r\narrange(\r\n  select(\r\n    mutate(\r\n      filter(\r\n        flights, \r\n        dest == \"IAH\"\r\n      ),\r\n      speed = distance / air_time * 60\r\n    ),\r\n    year:day, dep_time, carrier, flight, speed\r\n  ),\r\n  desc(speed)\r\n)\r\n\r\n\r\n# to this\r\n\r\n\r\nTo this.\r\n\r\n\r\nflights |> \r\n  filter(dest == \"IAH\") |> \r\n  mutate(speed = distance / air_time * 60) |> \r\n  select(year:day, dep_time, carrier, flight, speed) |> \r\n  arrange(desc(speed))\r\n\r\n# A tibble: 7,198 × 7\r\n    year month   day dep_time carrier flight    speed\r\n   <int> <int> <int>    <int> <chr>    <int>    <dbl>\r\n 1  2013     7     9      707 UA         226 521.7391\r\n 2  2013     8    27     1850 UA        1128 521.2270\r\n 3  2013     8    28      902 UA        1711 518.5185\r\n 4  2013     8    28     2122 UA        1022 518.5185\r\n 5  2013     6    11     1628 UA        1178 515.3374\r\n 6  2013     8    27     1017 UA         333 515.3374\r\n 7  2013     8    27     1205 UA        1421 515.3374\r\n 8  2013     8    27     1758 UA         302 515.3374\r\n 9  2013     9    27      521 UA         252 515.3374\r\n10  2013     8    28      625 UA         559 514.9091\r\n# ℹ 7,188 more rows\r\n\r\nsources\r\nThis post in stackoverflow\r\nThis blog by Isabella Velásquez. It is outdated because it is based in R 4.1, but it is still useful.\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-05-09T09:40:42-04:00",
    "input_file": "pipe.knit.md"
  }
]
